[{"id":0,"href":"/game-patching/","title":"Game Patching","parent":"Index","content":""},{"id":1,"href":"/game-files/scripts/san/","title":"SAN (Static Actors)","parent":"Scripts","content":"The SAN file is what stores all of the games static actors. A static actor is mapped to a LPD fileto handle that given actors logic.\nTable of contents      Table of contents  File Information File Header File Format  Actors section        File Information      Location: $GAMEDIR/client/script Extensions: san Encrypted File Name: rq9q1797qvs.san Decrypted File Name: StaticActor.san  File Header     The SAN file header is a simple struct which follows the following format:\nstruct header_t = { char file_type[4]; // Always \u0026#34;SANE\u0026#34;  char unknown[8]; // Unknown  char padding; } File Format     The SAN file format is fairly straight forward it contains a basic file header following with a list of all known actors within the game.\nstruct lpd_t = { header_t header; actor_t actors[]; } struct actor_t = { uint32 actor_id; // Actor ID as BE processed with a logical or of 0xA0F00000  char actor_name[...0x0]; // This is the name of the actor which is null terminated  char padding; } Actors section     The actors is an \u0026ldquo;encrypted\u0026rdquo; and can be decrypted using the following algorithm:\nchar decoded = encoded ^ 0x73 "},{"id":2,"href":"/game-files/executables/ffxivboot/","title":"Boot","parent":"Game Files","content":"The \u0026ldquo;ffxivboot.exe\u0026rdquo; executable is the main entry point for the game.\nTable of contents      Table of contents  Functionality Versions RSA Endpoints      Functionality     The \u0026ldquo;ffxivboot.exe\u0026rdquo; primary function is to check the Patch server if the game\u0026rsquo;s files are up to date by doing a get call to\n http://ver01.ffxiv.com/patch/vercheck/ffxiv/win32/release/{type}/{currentVersion}\nif there are any updates, then the server will respond with the needed torrents files, and then the \u0026ldquo;ffxivboot.exe\u0026rdquo; will act as a torrent client to download the files and pass them to \u0026ldquo;ffxivupdater.exe\u0026rdquo; after it finishes the download\nif there are no updates to be found, then \u0026ldquo;ffxivboot.exe\u0026rdquo; will launch \u0026ldquo;ffxivlogin.exe.\u0026rdquo;\nWhen Launching \u0026ldquo;ffxivlogin.exe\u0026rdquo; , the following command line argument is used\n{workingDirectory}\\ffxivlogin.exe sqex0001{base64string}//// the values that are used to generate the base64 are still unknown\nVersions     There are two versions for ffxivboot\n  2010.07.10.0000 SHA1:999EFB09D7D94C9C8106A75688CF3BED7C1FBA84\n  2010.09.18.0000 SHA1:598a0b090c496f392947055f2241e44218730668 \n  The First one gets installed through the initial game setup; as for the latter, it gets fetched and updated through the Patch server.\nThere is no difference in functionality between the two versions; it\u0026rsquo;s possible to use the stock version with the latest login and game exe.\nRSA     When downloading the patch from the Patch Server, \u0026ldquo;ffxivboot.exe\u0026rdquo; will run a series of checks to see if the source is actually \u0026ldquo;Square Enix,\u0026rdquo;\nThe Offset for the RSA Function in ffxivboot\nStock Version : 0x5DF50 Updated Version: 0x64310 These functions need to be patched out to bypass the checks and use a custom Patch Server.\nHere\u0026rsquo;s a recomened and tested patching value for the RSA function\n0xB8, 0x1F, 0x00, 0x00, 0x00, 0xC3\nalong with that the function needs to return true all the time\nStock Version : 0x5E32C Updated Version: 0x646EC Patch Value : 0x5E, 0x87, 0x48, 0x48, 0x06, 0xF8, 0x88 Endpoints     There are references to the following endpoints within \u0026ldquo;ffxivboot.exe.\u0026rdquo;\n  \u0026ldquo;lobby01.ffxiv.com\u0026rdquo;\n   Stock Version Offset : 0x8E5C6C\n   Updated Version Offset : 0x965D08\n    \u0026ldquo;secure.square-enix.com\u0026rdquo;\n   Stock Version Offset : 0x90A4A0\n   Updated Version Offset : 0x99212C\n    \u0026ldquo;ver01.ffxiv.com\u0026rdquo;\n   Stock Version Offset : 0x8E62DC\n   Updated Version Offset : 0x966404\n    The default port for the Patch Server is \u0026ldquo;54996.\u0026rdquo;\nStock Version Offset : 0x8E62D4 Updated Version Offset : 0x9663FC to be able to use a custom patch server, only \u0026ldquo;ver01.ffxiv.com\u0026rdquo; and the port needs to be modified\n"},{"id":3,"href":"/game-patching/patching/","title":"Client Patching","parent":"Game Patching","content":"Table of contents      Table of contents  Version Tracking Server  200 (Updating)  Headers Body   204 (No Update)   Torrent Server  Some thoughts        Version Tracking Server     Server Path: /patch/vercheck/ffxiv/win32/release/{type}/{currentVersion}\nThe version tracking server ver01.ffxiv.com is used to get the latest version of the client. This also serves as the download point for all the torrent files needed to download the proper patch files.\nThe server returns certain headers which are used to both verify the patch is from from ver01.ffvix.com and get the latest version.\n Type hash mapping: 2d2a390f: Boot 48eca647: Game  200 (Updating)     Headers      Content-Location: ffxiv/{type}/vercheck.dat Content-Type: multipart/mixed; boundary=477D80B1_38BC_41d4_8B48_5273ADB89CAC X-Repository: ffxiv/win32/release/boot X-Patch-Module: ZiPatch X-Protocol: torrent // Only torrent is supported X-info-url: http://example.com // Never gets used X-Latest-Version: {latestVersion} // Latest version of the given {type} Connection: keep-alive Body      --477D80B1_38BC_41d4_8B48_5273ADB89CAC Content-Type: application/octet-stream Content-Location: ffxiv/{type}/metainfo/D{version}.torrent X-Patch-Length: {size} // Size of the .patch file to download from the torrent X-Signature: jqxmt9WQH1aXptNju6CmCdztFdaKbyOAVjdGw_DJvRiBJhnQL6UlDUcqxg2DeiIKhVzkjUm3hFXOVUFjygxCoPUmCwnbCaryNqVk_oTk_aZE4HGWNOEcAdBwf0Gb2SzwAtk69zs_5dLAtZ0mPpMuxWJiaNSvWjEmQ925BFwd7Vk= // Signature of the response body // Empty Line ... Binary Data or torrent file ... Once you loop over versions starting at the request version to the latest verison you must end the request with\n--477D80B1_38BC_41d4_8B48_5273ADB89CAC-- Example Response\n Content-Location: ffxiv/{type}/vercheck.dat Content-Type: multipart/mixed; boundary=477D80B1_38BC_41d4_8B48_5273ADB89CAC X-Repository: ffxiv/win32/release/boot X-Patch-Module: ZiPatch X-Protocol: torrent // Only torrent is supported X-info-url: http://example.com // Never gets used X-Latest-Version: {latestVersion} // Latest version of the given {type} Connection: keep-alive --477D80B1_38BC_41d4_8B48_5273ADB89CAC Content-Type: application/octet-stream Content-Location: ffxiv/{type}/metainfo/D{version}.torrent X-Patch-Length: {size} // Size of the .patch file to download from the torrent X-Signature: {signature} // Signature of the response body // Empty Line ... Binary Data or torrent file ... --477D80B1_38BC_41d4_8B48_5273ADB89CAC Content-Type: application/octet-stream Content-Location: ffxiv/{type}/metainfo/D{version}.torrent X-Patch-Length: {size} // Size of the .patch file to download from the torrent X-Signature: {signature} // Signature of the response body // Empty Line ... Binary Data or torrent file ... --477D80B1_38BC_41d4_8B48_5273ADB89CAC Content-Type: application/octet-stream Content-Location: ffxiv/{type}/metainfo/D{version}.torrent X-Patch-Length: {size} // Size of the .patch file to download from the torrent X-Signature: {signature} // Signature of the response body // Empty Line ... Binary Data or torrent file ... --477D80B1_38BC_41d4_8B48_5273ADB89CAC-- 204 (No Update)      Content-Location: ffxiv/{type}/vercheck.dat Content-Type: multipart/mixed; boundary=477D80B1_38BC_41d4_8B48_5273ADB89CAC X-Repository: ffxiv/win32/release/boot X-Patch-Module: ZiPatch X-Protocol: torrent // Only torrent is supported X-info-url: http://example.com // Never gets used X-Latest-Version: {latestVersion} // Latest version of the given {type} Connection: keep-alive Torrent Server     All handshake/torrent request from the client updater hash the first 16 bytes of the torrents info hash using it\u0026rsquo;s own peerid. The resulting handshake from the seeder delivering the update decrypted the incoming infohash, discovers the proper torrent, and then send the handshake back encrypting the first 16 bytes with it\u0026rsquo;s own peerid.\nNote: The last 4 bytes of the incoming handshake info hash are the same as a tracked torrent\nvar incomingHash = new byte[20]; // This is the hash we found using the last 4 bytes  var discoveredHash = new byte[20]; var bf = new BlowFish(\u0026#34;-SQ0001-{GeneratedId}\u0026#34;); bf.Encrypt(discoveredHash, 0, 16); // Send the handshake back Some thoughts     We know the incoming hashes Blowfish key so we could decrypt the incoming hash and discover the proper torrent based on the full info hash. This would allow us to be more sure we are sending back the correct torrent every time.\nMaybe we could update the modified version of monotorrent to handle this instead of always using the last 4 bytes of the info hash. This requires more research due to how the announcement server works.\n"},{"id":4,"href":"/game-files/executables/ffxivgame/","title":"Game","parent":"Game Files","content":"\u0026ldquo;ffxivgame.exe\u0026rdquo; is the main game executable\nTable of contents      Table of contents  Lobby      Lobby     Once the game starts up it will try to communicate with the lobby server lobby01.ffxiv.com on the port 54994\nto be able to connect the game to a custom server , the lobby server address needs to be patched, it can be patched with either a hostname or a IP address\nThe lobby hostname is read from the following offset\n0xB90110 "},{"id":5,"href":"/game-files/","title":"Game Files","parent":"Index","content":""},{"id":6,"href":"/","title":"Index","parent":"","content":"Why does Project Novum exist?     The simplest reason I can give to why this exist is to research how the old FFXIV 1.0 - 1.23b game client worked. The lack of actual documentation on the game client is very minimal, and the documentation that does exist is very poorly written.\nWhy do you say other peoples documentation is poorly written?     For the simple fact they have just not wrote down any of there actual research.\nOn that note, I leave you with one of my favorite pieces of music:       "},{"id":7,"href":"/game-files/executables/ffxivlogin/","title":"Login","parent":"Game Files","content":"\u0026ldquo;ffxivlogin.exe\u0026rdquo; is a IE based broweser that\u0026rsquo;s used to render the Login page and read the session ID from the header once it\u0026rsquo;s populated\nTable of contents      Table of contents  Login Page  URL Encoding URL Decoding   Header      Login Page     The original Login Page URL was http://account.square-enix.com/account/content/ffxivlogin it\u0026rsquo;s present at the following offset in the binary file\n0x53EA0 The URL is encoded and not present as a plain text\nURL Encoding     Source : https://bitbucket.org/Ioncannon/project-meteor-server/src/master/Launcher%20Editor/Program.cspublic byte[] FFXIVLoginStringEncode(uint key, string text) { key = key \u0026amp; 0xFFFF; uint count = 0; byte[] asciiBytes = Encoding.ASCII.GetBytes(text); byte[] result = new byte[4 + text.Length]; for (count = 0; count \u0026lt; text.Length; count++) { result[result.Length - count - 1] = (byte)(asciiBytes[asciiBytes.Length - count - 1] ^ (key \u0026amp; 0xFF)); key += 0x22AF; key \u0026amp;= 0xFFFF; key = RotateLeft(key, 1); key \u0026amp;= 0xFFFF; } count = count ^ key; result[3] = (byte)(count \u0026amp; 0xFF); key += 0x22AF; key \u0026amp;= 0xFFFF; key = RotateLeft(key, 1); key \u0026amp;= 0xFFFF; result[2] = (byte)(key \u0026amp; 0xFF); key += 0x22AF; key \u0026amp;= 0xFFFF; key = RotateLeft(key, 1); key \u0026amp;= 0xFFFF; result[1] = (byte)(key \u0026amp; 0xFF); result[0] = (byte)((key \u0026gt;\u0026gt; 8) \u0026amp; 0xFF); return result; } URL Decoding     Source : https://bitbucket.org/Ioncannon/project-meteor-server/src/master/Launcher%20Editor/Program.cspublic string FFXIVLoginStringDecode(byte[] data) { Console.OutputEncoding = System.Text.Encoding.UTF8; while (true) { string result = \u0026#34;\u0026#34;; uint key = (uint)data[0] \u0026lt;\u0026lt; 8 | data[1]; uint key2 = data[2]; key = RotateRight(key, 1) \u0026amp; 0xFFFF; key -= 0x22AF; key \u0026amp;= 0xFFFF; key2 = key2 ^ key; key = RotateRight(key, 1) \u0026amp; 0xFFFF; key -= 0x22AF; key \u0026amp;= 0xFFFF; uint finalKey = key; key = data[3]; uint count = (key2 \u0026amp; 0xFF) \u0026lt;\u0026lt; 8; key = key ^ finalKey; key \u0026amp;= 0xFF; count |= key; int count2 = 0; while (count != 0) { uint encrypted = data[4 + count2]; finalKey = RotateRight(finalKey, 1) \u0026amp; 0xFFFF; finalKey -= 0x22AF; finalKey \u0026amp;= 0xFFFF; encrypted = encrypted ^ (finalKey \u0026amp; 0xFF); result += (char)encrypted; count--; count2++; } return result; } } Header     After the Player enters the username\u0026amp;password and get\u0026rsquo;s authenticated, the Login server will return the following header\n\u0026lt;x-sqexauth sid=\u0026#34;\u0026#34; lang=\u0026#34;\u0026#34; region=\u0026#34;\u0026#34; utc=\u0026#34;\u0026#34; /\u0026gt;  sid: The sessionID of the logged-in user lang: The default language of the user region: The region of the Player\u0026rsquo;s Square Enix Account utc: The key used for the Blowfish  once the \u0026ldquo;ffxivlogin.exe\u0026rdquo; detects the header in the page , it will construct the following string\nT =%d /LANG =%s /REGION =%d /SERVER_UTC =%s /SESSION_ID =%s  T: current tick count The rest is retrieved from the header  The string then will be Encrypted with Blowfish after that converted to Base64. After the conversion, it replaces the following from the base64 string\nString.Replace(\u0026#39;+\u0026#39;,\u0026#39;-\u0026#39;); String.Replace(\u0026#39;/\u0026#39;,\u0026#39;_\u0026#39;); Then ffxivlogin will launch the game with the following argument.\n{workingdirectory}\\ffxivgame.exe sqex0002{base64string}//// "},{"id":8,"href":"/tags/lpd/","title":"lpd","parent":"Tags","content":""},{"id":9,"href":"/game-files/scripts/lpd/","title":"LPD (Lua Program Data)","parent":"Scripts","content":"LPD files are what store the games LUA logic.\nTable of contents      Table of contents  File Information File Header File Format  Script section   File Name Format  Normal Script Program Script   File Name Conversion Notes      File Information      Location: $GAMEDIR/client/script Extensions: lpd  File Header     The LPD file header is a simple struct which follows the following format:\nstruct header_t = { char file_type[4]; // Always \u0026#34;RLE\\f\u0026#34;  uint32 version; // Always 1  uint32 file_size; // Unencrypted file size  char padding; } File Format     The LPD file format is fairly straight forward it contains a basic file header follow the above format, then followed by the compiled lua script.\nstruct lpd_t = { header_t header; char script[]; } Script section     The script is an \u0026ldquo;encrypted\u0026rdquo; form of the lua byte-code. The script can be decrypted using the following algorithm:\nchar decoded = encoded ^ 0x73 File Name Format     File names are formatted as the following:\nNormal Script: \u0026lt;script_name\u0026gt;.\u0026lt;le|be\u0026gt;.lpd Program Script: \u0026lt;script_name\u0026gt;_p.\u0026lt;le|be\u0026gt;.lpd Note: LE means Little Endian and BE means Big Endian\nNormal Script     A script is a script that can be required by a Program Script.\nProgram Script     A program script is what the client loads to handle the actual game logic for the lua script. In the client it converts the _p to .p on file load.\nFile Name Conversion     All file names in the scripts folder are encrypted, I haven\u0026rsquo;t found the actual algorithm used, to encrypte them. But I did discover that it is a basic substitution cipher, with the following key:\nNote: This doesn\u0026rsquo;t map all possible characters only the ones that I have observed to be used by the game.\nCharacter | Substituted Character 0 | j 1 | i 2 | h a | 9 b | 8 c | 7 d | 6 e | 5 f | 4 g | 3 h | 2 i | 1 j | 0 k | z l | y m | x n | w o | v p | u q | t r | s s | r t | q u | p v | o w | n y | l z | k Notes      All LUA files are using LUA 5.1 and can be recovered using something like LuaDec. All Lua scripts are compiled using Little Endian.  "},{"id":10,"href":"/tags/lua/","title":"lua","parent":"Tags","content":""},{"id":11,"href":"/tags/luac/","title":"luac","parent":"Tags","content":""},{"id":12,"href":"/tags/san/","title":"san","parent":"Tags","content":""},{"id":13,"href":"/game-files/scripts/","title":"Scripts","parent":"Game Files","content":""},{"id":14,"href":"/tags/scripts/","title":"scripts","parent":"Tags","content":""},{"id":15,"href":"/tags/static-actors/","title":"static actors","parent":"Tags","content":""},{"id":16,"href":"/tags/","title":"Tags","parent":"Index","content":""},{"id":17,"href":"/tags/zipatch/","title":"zipatch","parent":"Tags","content":""},{"id":18,"href":"/game-patching/zipatch/","title":"ZiPatch Format","parent":"Game Patching","content":"A ZiPatch file is the compressed format used by FFXIV to patch the games files. A newer version of this same format is used by FFXIV: ARR.\nThis documentation is for the ZiPatch format which is used by FFXIV 1.0 - 1.23b.\nNote: ZiPatch files are all Big Endian.\nTable of contents      Table of contents  File Information File Header File Footer Patch Blocks  Patch Block Structure  FHDR APLY APFS ADIR and DLED ETRY  ETRY Chunk            File Information      Location: Downloaded from patch server Extensions: patch  File Header     The file header is just 16 bytes long and it contains the following information:\nstruct header_t { char file_type[8] // ALways ‘ZIPATCH  char unknown[8] // Unknown bytes } File Footer     The last 8 bytes of the file are the CRC32 of the file.\nPatch Blocks     In with sections contains all the data related to the ZiPatch Blocks.\nPatch Block Structure     struct block_t { char block_type[4] // Type of the block (FHDR, APLY. APFS, ADIR, DLED, ETRY)  block_entry_t block_data[]; }  block_t information Is a struct that matches one of the types below.  FHDR     The over all changes that occur within the patch file such as number of files, number of directories added, and removed.\nstruct fhdr_t { char version[4] // Version of the patch file always [00, 00, 02, 00]  char result[4] // \u0026#34;DIFF\u0026#34; or \u0026#34;HIST\u0026#34;  uint32 num_Entry_Files; // Number of files being patched  uint32 num_Dirs_Added; // Number of directories added  uint32 num_Dirs_Deleted; // Number of directories deleted  } APLY     Two APLY always follow a FHDR block, it\u0026rsquo;s currently unknown what there purpose is.\nstruct aply_t { uint32 unknown1; uint32 unknown2; uint32 unknown3; } APFS     Note: This block is never actually used because FFXIV 1.X never released on anything other then PC\nUnknown to the purpose of this block but it is assumed to handle filesystem architecture in some way, maybe because the PS3 uses FAT32 and Windows uses NTFS.\nstruct apfs_t { 0 }; ADIR and DLED     These blocks are basically the same thing, ADIR is to add a directory and DLED is to delete a directory.\nstruct adir_t { uint pathLength; char path[]; } struct dled_t { uint pathLength; char path[]; } ETRY     These blocks contains chunks of data that are to be used during patching.\nstruct etry_t { uint32 filePathLength; char filePath[]; uint32 totalChunks; chunk_t chunks[]; char padding[8]; } ETRY Chunk     The chunk of data that is apart of a ETRY block.\nstruct chunk_t { uint32 mode; // 0x41 = Add, 0x44 = Delete, 0x4D = Modify  char previous_hash[20]; // Hash of the previous file  char new_hash[20]; // Hash of the new file  int compression_Mode; // 0x4E = Uncompressed, 0x54 Compressed (zlib)  uint32 file_Size; // Size of the file based on the compression_mode  uint32 previous_File_Size; // Size of the previous file  uint32 new_File_Size; // Size of the new file  char data[]; // The actual data size is based on the file_size  }  Handling mode of a chunk 0x41: Create a new file with the data 0x44: Delete the given file 0x4D: Modify the given file (Basically overwrite it with the new file) Handling hashes When a file is being added previous_hash is set to 0x00 When deleting a file new_hash is set to 0x00 and the data is set to 0x00 Handling compression_mode 0x4E: Data stream is uncompressed 0x54: Data stream is compressed with zlib  "}]