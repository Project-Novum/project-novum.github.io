[{"id":0,"href":"/game-patching/","title":"Game Patching","parent":"Index","content":""},{"id":1,"href":"/game-files/scripts/san/","title":"SAN (Static Actors)","parent":"Scripts","content":"The SAN file is what stores all of the games static actors. A static actor is mapped to a LPD fileto handle that given actors logic.\nTable of contents      Table of contents  File Information File Header File Format  Actors section        File Information      Location: $GAMEDIR/client/script Extensions: san Encrypted File Name: rq9q1797qvs.san Decrypted File Name: StaticActor.san  File Header     The SAN file header is a simple struct which follows the following format:\nstruct header_t = { char file_type[4]; // Always \u0026#34;SANE\u0026#34;  char unknown[8]; // Unknown  char padding; } File Format     The SAN file format is fairly straight forward it contains a basic file header following with a list of all known actors within the game.\nstruct lpd_t = { header_t header; actor_t actors[]; } struct actor_t = { uint32 actor_id; // Actor ID as BE processed with a logical or of 0xA0F00000  char actor_name[...0x0]; // This is the name of the actor which is null terminated  char padding; } Actors section     The actors is an \u0026ldquo;encrypted\u0026rdquo; and can be decrypted using the following algorithm:\nchar decoded = encoded ^ 0x73 "},{"id":2,"href":"/game-patching/patching/","title":"Client Patching","parent":"Game Patching","content":"Table of contents      Table of contents  Version Tracking Server  200 (Updating)  Headers Body   204 (No Update)   Torrent Server  Some thoughts        Version Tracking Server     Server Path: /patch/vercheck/ffxiv/win32/release/{type}/{currentVersion}\nThe version tracking server ver01.ffxiv.com is used to get the latest version of the client. This also serves as the download point for all the torrent files needed to download the proper patch files.\nThe server returns certain headers which are used to both verify the patch is from from ver01.ffvix.com and get the latest version.\n Type hash mapping: 2d2a390f: Boot 48eca647: Game  200 (Updating)     Headers      Content-Location: ffxiv/{type}/vercheck.dat Content-Type: multipart/mixed; boundary=477D80B1_38BC_41d4_8B48_5273ADB89CAC X-Repository: ffxiv/win32/release/boot X-Patch-Module: ZiPatch X-Protocol: torrent // Only torrent is supported X-info-url: http://example.com // Never gets used X-Latest-Version: {latestVersion} // Latest version of the given {type} Connection: keep-alive Body      --477D80B1_38BC_41d4_8B48_5273ADB89CAC Content-Type: application/octet-stream Content-Location: ffxiv/{type}/metainfo/D{version}.torrent X-Patch-Length: {size} // Size of the .patch file to download from the torrent X-Signature: jqxmt9WQH1aXptNju6CmCdztFdaKbyOAVjdGw_DJvRiBJhnQL6UlDUcqxg2DeiIKhVzkjUm3hFXOVUFjygxCoPUmCwnbCaryNqVk_oTk_aZE4HGWNOEcAdBwf0Gb2SzwAtk69zs_5dLAtZ0mPpMuxWJiaNSvWjEmQ925BFwd7Vk= // Signature of the response body // Empty Line ... Binary Data or torrent file ... Once you loop over versions starting at the request version to the latest verison you must end the request with\n--477D80B1_38BC_41d4_8B48_5273ADB89CAC-- Example Response\n Content-Location: ffxiv/{type}/vercheck.dat Content-Type: multipart/mixed; boundary=477D80B1_38BC_41d4_8B48_5273ADB89CAC X-Repository: ffxiv/win32/release/boot X-Patch-Module: ZiPatch X-Protocol: torrent // Only torrent is supported X-info-url: http://example.com // Never gets used X-Latest-Version: {latestVersion} // Latest version of the given {type} Connection: keep-alive --477D80B1_38BC_41d4_8B48_5273ADB89CAC Content-Type: application/octet-stream Content-Location: ffxiv/{type}/metainfo/D{version}.torrent X-Patch-Length: {size} // Size of the .patch file to download from the torrent X-Signature: {signature} // Signature of the response body // Empty Line ... Binary Data or torrent file ... --477D80B1_38BC_41d4_8B48_5273ADB89CAC Content-Type: application/octet-stream Content-Location: ffxiv/{type}/metainfo/D{version}.torrent X-Patch-Length: {size} // Size of the .patch file to download from the torrent X-Signature: {signature} // Signature of the response body // Empty Line ... Binary Data or torrent file ... --477D80B1_38BC_41d4_8B48_5273ADB89CAC Content-Type: application/octet-stream Content-Location: ffxiv/{type}/metainfo/D{version}.torrent X-Patch-Length: {size} // Size of the .patch file to download from the torrent X-Signature: {signature} // Signature of the response body // Empty Line ... Binary Data or torrent file ... --477D80B1_38BC_41d4_8B48_5273ADB89CAC-- 204 (No Update)      Content-Location: ffxiv/{type}/vercheck.dat Content-Type: multipart/mixed; boundary=477D80B1_38BC_41d4_8B48_5273ADB89CAC X-Repository: ffxiv/win32/release/boot X-Patch-Module: ZiPatch X-Protocol: torrent // Only torrent is supported X-info-url: http://example.com // Never gets used X-Latest-Version: {latestVersion} // Latest version of the given {type} Connection: keep-alive Torrent Server     All handshake/torrent request from the client updater hash the first 16 bytes of the torrents info hash using it\u0026rsquo;s own peerid. The resulting handshake from the seeder delivering the update decrypted the incoming infohash, discovers the proper torrent, and then send the handshake back encrypting the first 16 bytes with it\u0026rsquo;s own peerid.\nNote: The last 4 bytes of the incoming handshake info hash are the same as a tracked torrent\nvar incomingHash = new byte[20]; // This is the hash we found using the last 4 bytes  var discoveredHash = new byte[20]; var bf = new BlowFish(\u0026#34;-SQ0001-{GeneratedId}\u0026#34;); bf.Encrypt(discoveredHash, 0, 16); // Send the handshake back Some thoughts     We know the incoming hashes Blowfish key so we could decrypt the incoming hash and discover the proper torrent based on the full info hash. This would allow us to be more sure we are sending back the correct torrent every time.\nMaybe we could update the modified version of monotorrent to handle this instead of always using the last 4 bytes of the info hash. This requires more research due to how the announcement server works.\n"},{"id":3,"href":"/game-files/","title":"Game Files","parent":"Index","content":""},{"id":4,"href":"/","title":"Index","parent":"","content":"Why does Project Novum exist?     The simplest reason I can give to why this exist is to research how the old FFXIV 1.0 - 1.23b game client worked. The lack of actual documentation on the game client is very minimal, and the documentation that does exist is very poorly written.\nWhy do you say other peoples documentation is poorly written?     For the simple fact they have just not wrote down any of there actual research.\nOn that note, I leave you with one of my favorite pieces of music:       "},{"id":5,"href":"/tags/lpd/","title":"lpd","parent":"Tags","content":""},{"id":6,"href":"/game-files/scripts/lpd/","title":"LPD (Lua Program Data)","parent":"Scripts","content":"LPD files are what store the games LUA logic.\nTable of contents      Table of contents  File Information File Header File Format  Script section   File Name Format  Normal Script Program Script   File Name Conversion Notes      File Information      Location: $GAMEDIR/client/script Extensions: lpd  File Header     The LPD file header is a simple struct which follows the following format:\nstruct header_t = { char file_type[4]; // Always \u0026#34;RLE\\f\u0026#34;  uint32 version; // Always 1  uint32 file_size; // Unencrypted file size  char padding; } File Format     The LPD file format is fairly straight forward it contains a basic file header follow the above format, then followed by the compiled lua script.\nstruct lpd_t = { header_t header; char script[]; } Script section     The script is an \u0026ldquo;encrypted\u0026rdquo; form of the lua byte-code. The script can be decrypted using the following algorithm:\nchar decoded = encoded ^ 0x73 File Name Format     File names are formatted as the following:\nNormal Script: \u0026lt;script_name\u0026gt;.\u0026lt;le|be\u0026gt;.lpd Program Script: \u0026lt;script_name\u0026gt;_p.\u0026lt;le|be\u0026gt;.lpd Note: LE means Little Endian and BE means Big Endian\nNormal Script     A script is a script that can be required by a Program Script.\nProgram Script     A program script is what the client loads to handle the actual game logic for the lua script. In the client it converts the _p to .p on file load.\nFile Name Conversion     All file names in the scripts folder are encrypted, I haven\u0026rsquo;t found the actual algorithm used, to encrypte them. But I did discover that it is a basic substitution cipher, with the following key:\nNote: This doesn\u0026rsquo;t map all possible characters only the ones that I have observed to be used by the game.\nCharacter | Substituted Character 0 | j 1 | i 2 | h a | 9 b | 8 c | 7 d | 6 e | 5 f | 4 g | 3 h | 2 i | 1 j | 0 k | z l | y m | x n | w o | v p | u q | t r | s s | r t | q u | p v | o w | n y | l z | k Notes      All LUA files are using LUA 5.1 and can be recovered using something like LuaDec. All Lua scripts are compiled using Little Endian.  "},{"id":7,"href":"/tags/lua/","title":"lua","parent":"Tags","content":""},{"id":8,"href":"/tags/luac/","title":"luac","parent":"Tags","content":""},{"id":9,"href":"/tags/san/","title":"san","parent":"Tags","content":""},{"id":10,"href":"/game-files/scripts/","title":"Scripts","parent":"Game Files","content":""},{"id":11,"href":"/tags/scripts/","title":"scripts","parent":"Tags","content":""},{"id":12,"href":"/tags/static-actors/","title":"static actors","parent":"Tags","content":""},{"id":13,"href":"/tags/","title":"Tags","parent":"Index","content":""},{"id":14,"href":"/tags/zipatch/","title":"zipatch","parent":"Tags","content":""},{"id":15,"href":"/game-patching/zipatch/","title":"ZiPatch Format","parent":"Game Patching","content":"A ZiPatch file is the compressed format used by FFXIV to patch the games files. A newer version of this same format is used by FFXIV: ARR.\nThis documentation is for the ZiPatch format which is used by FFXIV 1.0 - 1.23b.\nNote: ZiPatch files are all Big Endian.\nTable of contents      Table of contents  File Information File Header File Footer Patch Blocks  Patch Block Structure  FHDR APLY APFS ADIR and DLED ETRY  ETRY Chunk            File Information      Location: Downloaded from patch server Extensions: patch  File Header     The file header is just 16 bytes long and it contains the following information:\nstruct header_t { char file_type[8] // ALways â€˜ZIPATCH  char unknown[8] // Unknown bytes } File Footer     The last 8 bytes of the file are the CRC32 of the file.\nPatch Blocks     In with sections contains all the data related to the ZiPatch Blocks.\nPatch Block Structure     struct block_t { char block_type[4] // Type of the block (FHDR, APLY. APFS, ADIR, DLED, ETRY)  block_entry_t block_data[]; }  block_t information Is a struct that matches one of the types below.  FHDR     The over all changes that occur within the patch file such as number of files, number of directories added, and removed.\nstruct fhdr_t { char version[4] // Version of the patch file always [00, 00, 02, 00]  char result[4] // \u0026#34;DIFF\u0026#34; or \u0026#34;HIST\u0026#34;  uint32 num_Entry_Files; // Number of files being patched  uint32 num_Dirs_Added; // Number of directories added  uint32 num_Dirs_Deleted; // Number of directories deleted  } APLY     Two APLY always follow a FHDR block, it\u0026rsquo;s currently unknown what there purpose is.\nstruct aply_t { uint32 unknown1; uint32 unknown2; uint32 unknown3; } APFS     Note: This block is never actually used because FFXIV 1.X never released on anything other then PC\nUnknown to the purpose of this block but it is assumed to handle filesystem architecture in some way, maybe because the PS3 uses FAT32 and Windows uses NTFS.\nstruct apfs_t { 0 }; ADIR and DLED     These blocks are basically the same thing, ADIR is to add a directory and DLED is to delete a directory.\nstruct adir_t { uint pathLength; char path[]; } struct dled_t { uint pathLength; char path[]; } ETRY     These blocks contains chunks of data that are to be used during patching.\nstruct etry_t { uint32 filePathLength; char filePath[]; uint32 totalChunks; chunk_t chunks[]; char padding[8]; } ETRY Chunk     The chunk of data that is apart of a ETRY block.\nstruct chunk_t { uint32 mode; // 0x41 = Add, 0x44 = Delete, 0x4D = Modify  char previous_hash[20]; // Hash of the previous file  char new_hash[20]; // Hash of the new file  int compression_Mode; // 0x4E = Uncompressed, 0x54 Compressed (zlib)  uint32 file_Size; // Size of the file based on the compression_mode  uint32 previous_File_Size; // Size of the previous file  uint32 new_File_Size; // Size of the new file  char data[]; // The actual data size is based on the file_size  }  Handling mode of a chunk 0x41: Create a new file with the data 0x44: Delete the given file 0x4D: Modify the given file (Basically overwrite it with the new file) Handling hashes When a file is being added previous_hash is set to 0x00 When deleting a file new_hash is set to 0x00 and the data is set to 0x00 Handling compression_mode 0x4E: Data stream is uncompressed 0x54: Data stream is compressed with zlib  "}]